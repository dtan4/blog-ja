<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>GitHub on blog-ja.dtan4.net</title><link>https://blog-ja.dtan4.net/tags/github/</link><description>Recent content in GitHub on blog-ja.dtan4.net</description><generator>Hugo -- gohugo.io</generator><language>ja-JP</language><copyright>Copyright &amp;copy; 2020 dtan4 All Rights Reserved</copyright><lastBuildDate>Tue, 31 Jan 2017 00:00:00 +0000</lastBuildDate><atom:link href="https://blog-ja.dtan4.net/tags/github/index.xml" rel="self" type="application/rss+xml"/><item><title>GitHub Releases にアップロードしてある最新バージョンの成果物を取得するワンライナー</title><link>https://blog-ja.dtan4.net/posts/qiita-1a9f16ff881ac456c18f/</link><pubDate>Tue, 31 Jan 2017 00:00:00 +0000</pubDate><guid>https://blog-ja.dtan4.net/posts/qiita-1a9f16ff881ac456c18f/</guid><description>この記事はQiitaの記事をエクスポートしたものです。内容が古くなっている可能性があります。
e.g. dtan4/s3url 最新バージョンの Linux 64bit バイナリが入った tarball を取得する
$ curl -s https://api.github.com/repos/dtan4/s3url/releases | jq -r &amp;#39;.[0].assets[] | select(.name | test(&amp;#34;linux-amd64.tar.gz&amp;#34;)) | .browser_download_url&amp;#39; https://github.com/dtan4/s3url/releases/download/v0.3.1/s3url-v0.3.1-linux-amd64.tar.gz サーバに Go バイナリを配置していて定期的に更新したい場合は、このワンライナーと展開処理を行うスクリプトを cron とかで回しておけばよさそうです。
curl -s https://api.github.com/repos/dtan4/s3url/releases dtan4/s3url リポジトリの Releases を取得する GitHub API です。 Public リポジトリなら認証無しで叩けますが、その場合の呼出回数は1時間あたり最大60回となってるので、Access Token を付与するほうが安心です。
Releases | GitHub Developer Guide
jq -r -r オプションをつけると、ダブルクオートで囲まずそのまま文字列を返します。
.[0].assets[] 上記 API のレスポンスは Release 作成時刻 created_at 降順になっているので、先頭の要素が最新の Release となります。assets に成果物 (asset) のメタデータが配列で格納されてます。
select(.name | test(&amp;quot;linux-amd64.tar.gz&amp;quot;)) name フィールドが linux-amd64.</description></item><item><title>Travis CI から複数ファイルを GitHub Releases にアップロードする</title><link>https://blog-ja.dtan4.net/posts/qiita-f2736c25c4eb63b2d206/</link><pubDate>Thu, 22 Sep 2016 00:00:00 +0000</pubDate><guid>https://blog-ja.dtan4.net/posts/qiita-f2736c25c4eb63b2d206/</guid><description>この記事はQiitaの記事をエクスポートしたものです。内容が古くなっている可能性があります。
Travis CI から GitHub Releases にアップロードする Go などのコンパイラ言語で書いたソフトウェアを配布する場所として、最近は GitHub Releases を使うことが多いと思います。単純に Git tag と紐付けてファイルをアップロードする場所ですが、手作業でやるのも面倒なので CI と連携させるのが便利です。
Travis CI には Deployment の機能があります。その名の通り、アプリケーションのテスト/ビルド後に、外部の指定した場所へ成果物をデプロイする機能です。デプロイするトリガーとして「特定のブランチ」「git tag がプッシュされた場合のみ」「Go 1.7 ビルドのみ」のような条件が指定できます。
Deployment は、標準で GitHub Releases のインテグレーションを備えています (GitHub Releases Uploading - Travis CI)。GitHub Access Token だけ与えればあとはよしなにアップロードしてくれる便利君ですが、複数ファイルアップロードしたいときに難がありました。
file にアップロード対象のファイルを列挙する 公式ドキュメントで紹介されている方法です。以下は ec2c のバイナリパッケージを12個アップロードする例です。
https://docs.travis-ci.com/user/deployment/releases/#Uploading-Multiple-Files
deploy: provider: releases skip_cleanup: true api_key: $GITHUB_TOKEN file: - dist/ec2c-0.1.0-darwin-386.tar.gz - dist/ec2c-0.1.0-darwin-386.zip - dist/ec2c-0.1.0-darwin-amd64.tar.gz - dist/ec2c-0.1.0-darwin-amd64.zip - dist/ec2c-0.1.0-linux-386.tar.gz - dist/ec2c-0.1.0-linux-386.zip - dist/ec2c-0.1.0-linux-amd64.tar.gz - dist/ec2c-0.1.0-linux-amd64.zip - dist/ec2c-0.</description></item><item><title>GitHub にパスワードとかセンシティブなファイルを push してしまったときの対処法</title><link>https://blog-ja.dtan4.net/posts/qiita-34e41e3bd40a43fd8cbf/</link><pubDate>Sat, 19 Dec 2015 00:00:00 +0000</pubDate><guid>https://blog-ja.dtan4.net/posts/qiita-34e41e3bd40a43fd8cbf/</guid><description>この記事はQiitaの記事をエクスポートしたものです。内容が古くなっている可能性があります。
.gitignore し忘れて他人に見えちゃマズいファイル（パスワードをベタ書きしたファイルや AWS_SECRET_ACCESS_KEY を書いたファイルとか）を git commit しちゃった！そんなときは
$ git reset --hard HEAD~ すればすぐ何もなかったことにできます。
が！そこで気付かずに GitHub へ git push してしまった！こうなると容易に何もなかったことにはできません。
この記事では、こういうときに何もなかったことにする方法を紹介します。
そのデータを無効にする 特に Public Repository の場合はすでにそのデータが他人の目に触れていた…ということも十分ありえます。AWS_SECRET_ACCESS_KEY なんかは取得用のクローラが存在するとも聞きます。ので、まずは不正利用されても影響が出ないように、__パスワードの書き換えやトークンの無効化__を施しましょう。
（この時点でもう何もなかったことになってない気がする）
git の履歴から該当のファイルを消す git reset と git filter-branch 2つの方法があります。
git reset (2015-12-29 15:00 追記) git reset だとセンシティブファイル以外の作業履歴もすべて消去されてしまうので、それらを残しておきたい場合は後述 git filter-branch でコミットを書き換えるようにしてください。 (追記終わり)
該当ファイルを git commit してすぐ気づいた (3コミット以内) なら、まだ git reset で消せます。
$ git reset --hard HEAD~2 ＃ 消すコミットの数 git filter-branch 気づいたのはそこから何コミットもしたあと…だと git reset でそこまでの履歴を全部消すのは現実的ではありません。そんな時に役立つのが git filter-branch です。filter-branch は普段見慣れない（であってほしい）ですが、__大量のコミットを機械的に書き換える__コマンドです。今回みたいにファイルを消す以外にも、リポジトリ全体のコミットオーサーの書き換えとかも一発でできます。</description></item><item><title>プロダクトに名前をつける時に気をつけたいこと</title><link>https://blog-ja.dtan4.net/posts/qiita-639928bcfc6ac0a69a57/</link><pubDate>Mon, 14 Dec 2015 00:00:00 +0000</pubDate><guid>https://blog-ja.dtan4.net/posts/qiita-639928bcfc6ac0a69a57/</guid><description>この記事はQiitaの記事をエクスポートしたものです。内容が古くなっている可能性があります。
私は今まで、数々のアプリケーションやライブラリをつくって GitHub / RubyGems 等で公開してきました。ここで毎回注意しているのが__プロダクトの名前の付け方__です。この記事では、自分が何に気をつけて名付けをしているのかを紹介します。
ユニークな名前にする ユニークな名前にする、つまり__既に公開されているものとなるべく名前が被らないようにすべき__です。ユニークな名前にすることでググラビリティ（検索した時のヒットしやすさ）を高めることができますし、エゴサーチもしやすくなります。
同じ名前のプロダクトがすでに存在しないかチェックする 自分はよさ気な名前が思いついたら、まず Google 検索と GitHub の一番上にある検索ボックスに突っ込みます。同じ名前のリポジトリがすでにあるかどうかを調べるためです。ハイフンとかを含めるなら名前をダブルクォートで囲むのが良いでしょう。
幸運にもリポジトリが一件もヒットしない場合は、その名前を採用します。もしヒットした場合でも、数が少ない &amp;amp; 全然開発されていなかったり (Initial commit だけみたいな)、Star が全然ついてない場合は採用することがあります。自分のほうが有名になってやるぞ！という勢いです。
プロダクトを RubyGems や npm などのパッケージ管理システムに上げる場合は、そこでも名前を検索する必要があります。ここで被っているとさすがに登録できないので…
DeNA が作っている JSX と React.js の JSX や、プログラミング言語 Go と Thoughtworks が出してる GoCD とか、正直どうしてぶつかった感があります…
辞書に載っているような単語はなるべく避ける 英語の普通名詞や固有名詞はなるべく避けた方がいいです。よほどそのプロダクトが（それこそ Ruby とか Go みたいに）ヒットしない限り、その名前単体で Google 検索して引っかかることは相当厳しいでしょう。
とはいえ、適当にタイプした母音のないような単語は好ましくありません。発音しにくい &amp;amp; 覚えにくいというのはマイナスです。単語をそのまま使わず、少しもじったり組み合わせたりするとよいでしょう。フレーズを作って、単語の頭文字をつなげ合わせるのもよいです。Linux (Linux Is Not UniX) のような再帰的頭字語を作れるとカッコいいです。
あるいは、英語以外の単語・フレーズで考えるとユニーク性は増します。Google 翻訳の左欄に日本語なり英語の単語を入れて、右欄の言語を変えまくってよさそうな表記を探したりします。
ラテン語とかエスペラントとかはそうそう被らないでしょう（README に説明を書くべきだとは思いますが）。日本語のローマ字表記や中国語のピンインも意外と穴場だったりします。
キーボードでタイプしやすい名前にする :warning: 世の中 Dvorak 配列とか AZERTY 配列とかありますが、自分は大多数を占める QWERTY 配列における打ちやすさを考えています。 :warning:</description></item><item><title>クラウドサービスを活用して README にバッジをペタペタ貼る</title><link>https://blog-ja.dtan4.net/posts/qiita-13b0ea9edf5b99926446/</link><pubDate>Sat, 31 Oct 2015 00:00:00 +0000</pubDate><guid>https://blog-ja.dtan4.net/posts/qiita-13b0ea9edf5b99926446/</guid><description>この記事はQiitaの記事をエクスポートしたものです。内容が古くなっている可能性があります。
最近の GitHub に上げてある OSS リポジトリには、README にいろんなバッジが貼られています。リポジトリに連携しているクラウドサービスのステータスを表すものがほとんどです。 自分は README にバッジを貼りたい派です。たとえば dtan4/terraforming だとこういう感じです。
最近はバッジの種類も増えているので、整理のためにもどういうのがあるかまとめてみようと思います。
自分がよく README に貼っているバッジ 自分が書く RubyGems については、以下の6個のバッジを必ずつけるようにしています。
Travis CI
言わずと知れた CI サービス。現在の master が CI 通っている (passing) かコケている (failed) かがわかります。リポジトリのメンテナンス状況を把握するのによいです。
クリックすれば、そのリポジトリのテスト結果を見ることができます。
Code Climate
ソースコードの品質チェックをしてくれるサービスです。リポジトリ内のコード重複や複雑性を解析して GPA (最高 4.0) を算出してくれます。このリポジトリのコード品質がどうであるか、をひと目で確認できます。Ruby の他にも Node.js や PHP, Python に対応してます。
最近はテストカバレッジの取得にも対応しました。Travis CI のテスト後にテストカバレッジが Code Climate へアップロードされます。 以前はテストカバレッジの表示に Coveralls を使っていましたが、Code Climate でひとまとめに見られるようになったので最近はこっちを使うようにしています。
クリックすれば、そのリポジトリの詳細な解析結果と行単位のテストカバレッジを見ることができます。
Gemnasium
アプリケーションの依存管理をチェックしてくれるサービスです。Ruby だと Gemfile, Gemfile.lock, *.gemspec を解析し、指定されている依存ライブラリのバージョンが古くなったら警告を出してくれます。Ruby の他にも Node.</description></item></channel></rss>