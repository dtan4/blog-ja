<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CoreOS on blog-ja.dtan4.net</title><link>http://blog-ja.dtan4.net/tags/coreos/</link><description>Recent content in CoreOS on blog-ja.dtan4.net</description><generator>Hugo -- gohugo.io</generator><language>ja-JP</language><copyright>Copyright &amp;copy; 2020 dtan4 All Rights Reserved</copyright><lastBuildDate>Wed, 15 Jun 2016 00:00:00 +0000</lastBuildDate><atom:link href="http://blog-ja.dtan4.net/tags/coreos/index.xml" rel="self" type="application/rss+xml"/><item><title>CoreOS で ECS クラスタを構築する</title><link>http://blog-ja.dtan4.net/posts/qiita-a98ceb194ed4854bb300/</link><pubDate>Wed, 15 Jun 2016 00:00:00 +0000</pubDate><guid>http://blog-ja.dtan4.net/posts/qiita-a98ceb194ed4854bb300/</guid><description>この記事はQiitaの記事をエクスポートしたものです。内容が古くなっている可能性があります。
ECS クラスタを作るにあたって土台の EC2 インスタンスが必要となるわけですが、そこで使う AMI として公式では ECS-optimized AMI を推奨しています。ECS-optimized AMI は Amazon Linux AMI に新し目の Docker と ecs-agent、ecs-init スクリプトを同梱したやつです。初回チュートリアルでクラスタを立てる時もこの AMI が使われます。
ただ、実際のところ EC2 の中身に関しては (2016-06-15 時点)
Linux Kernel 3.10 以上で Docker 1.5.0 以上で ecs-agent コンテナが立ってる のであれば何でもよいのです。ECS-optimized AMI はそれを満たした推奨構成であるだけです。
というわけで、Docker 環境に特化した CoreOS を使ってみましょう。
ECS クラスタを準備 まっさらからクラスタ建てる場合は、Management Console なり ecs-cli なりで新しくクラスタを作ってください。 もしくは、既存クラスタにノード追加の形で CoreOS インスタンスを追加することもできます。
（ないなら）IAM Role ecsInstanceRole を作成 ecs-agent が ECS API にアクセスするため、その権限をインスタンスに付与してあげる必要があります。 初回チュートリアルでクラスタを立ち上げた場合は作られてると思いますが、まっさらからクラスタを構築する場合はこの Role がないので作る必要があります。
IAM -&amp;gt; Roles -&amp;gt; Create New Role を開く [AWS Service Role] の [Amazon EC2] を開き、AmazonEC2ContainerServiceforEC2Role にチェックを入れる [Create Role] 作った Role を開き、[Trusted Relationships] -&amp;gt; [Show policy document] が以下のようになっているのを確認。なってなかったら上書き。 { &amp;#34;Version&amp;#34;: &amp;#34;2008-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Sid&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Principal&amp;#34;: { &amp;#34;Service&amp;#34;: &amp;#34;ec2.</description></item><item><title>CoreOS で Docker デーモンの起動オプション DOCKER_OPTS を設定する</title><link>http://blog-ja.dtan4.net/posts/qiita-2212607d13ad7c81120e/</link><pubDate>Mon, 16 May 2016 00:00:00 +0000</pubDate><guid>http://blog-ja.dtan4.net/posts/qiita-2212607d13ad7c81120e/</guid><description>この記事はQiitaの記事をエクスポートしたものです。内容が古くなっている可能性があります。
CoreOS は何もしなくとも自動で Docker デーモンが立ち上がりますが、たまに Docker デーモン自体の起動オプション (DOCKER_OPTS) を設定したい時があります。Docker デーモンへのアクセスには TLS 認証使いたいとか、overlay network を使うための下準備をしたいとかです。
そういう時は、cloud-config の units に docker.service を記述することで Docker デーモンの起動時に DOCKER_OPTS を設定できます。 以下の例では、etcd を利用した overlay network 構築 のオプションを指定しています。
coreos: units: - name: etcd2.service command: start - name: docker.service # &amp;lt;===== drop-ins: - name: 10-cluster-config.conf content: | [Service] Environment=&amp;#34;DOCKER_OPTS=--cluster-store=etcd://0.0.0.0:2379 --cluster-advertise=eth0:2375&amp;#34; REF Customizing docker</description></item><item><title>CoreOS でも tcpdump したい (CoreOS toolbox)</title><link>http://blog-ja.dtan4.net/posts/qiita-50fd75b56660ed8aa158/</link><pubDate>Mon, 28 Sep 2015 00:00:00 +0000</pubDate><guid>http://blog-ja.dtan4.net/posts/qiita-50fd75b56660ed8aa158/</guid><description>この記事はQiitaの記事をエクスポートしたものです。内容が古くなっている可能性があります。
CoreOS 上でも tcpdump でネットワークデバッグする話です。
tcpdump くらいあるやろ core@core-01 ~ $ tcpdump -bash: tcpdump: command not found 無いんですよねー
CoreOS toolbox https://github.com/coreos/toolbox
CoreOS は OS 本体に何も入ってない（からアプリケーションは Docker コンテナとして動かす）ことで有名ですが、上記のように tcpdump すら入ってないので特に低レイヤーの調査で困ることがあります。それを補助するために、CoreOS が公式に toolbox というのを提供しています。
実際に使ってみましょう。
core@core-01 ~ $ /usr/bin/toolbox latest: Pulling from fedora 48ecf305d2cf: Pull complete ded7cd95e059: Pull complete fedora:latest: The image you are pulling has been verified. Important: image verification is a tech preview feature and should not be relied on to provide security.</description></item><item><title>CoreOS + flannel で複数ホスト間コンテナ通信をする</title><link>http://blog-ja.dtan4.net/posts/qiita-8f9cf40aabd2e6c9a494/</link><pubDate>Thu, 02 Apr 2015 00:00:00 +0000</pubDate><guid>http://blog-ja.dtan4.net/posts/qiita-8f9cf40aabd2e6c9a494/</guid><description>この記事はQiitaの記事をエクスポートしたものです。内容が古くなっている可能性があります。
CoreOS が提供する flannel を使って、複数の CoreOS マシンを跨いで Docker コンテナ同士通信できるようにする、というお話です。
flannel もともと Kubernates には似たようなホスト間通信機能がついていたのですが、Google Compute Engine (GCE) 上でしか使えないという欠点がありました。これを取り出し、汎用的に使えるようにしたのが flannel です。
また、似た機能を持つものに weave がありますが、weave は導入が少々面倒な上に相手ホストの IP を明示的に指定してあげないといけません。その点 flannel は CoreOS 上での導入が簡単で、相手の IP を知らなくてもよく透過的に利用できるという利点があります。ホストに割り振られる IP が不定である EC2 + VPC 構成でも使いやすいでしょう。
イメージ図はこんな感じです。
(from https://github.com/coreos/flannel/blob/master/packet-01.png)
試してみる 以下で紹介する CoreOS VM を含めたサンプルリポジトリです。あわせてご利用ください: dtan4/coreos-flannel-sample
cloud-config まず cloud-config はこんな感じです。flanneld.service というのを定義しています。
#cloud-config coreos: etcd: discovery: https://discovery.etcd.io/&amp;lt;token&amp;gt; addr: $public_ipv4:4001 peer-addr: $public_ipv4:7001 fleet: public-ip: $public_ipv4 flannel: interface: $public_ipv4 units: - name: etcd.service command: start - name: fleet.</description></item></channel></rss>