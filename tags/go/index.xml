<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go on blog-ja.dtan4.net</title><link>http://blog-ja.dtan4.net/tags/go/</link><description>Recent content in Go on blog-ja.dtan4.net</description><generator>Hugo -- gohugo.io</generator><language>ja-JP</language><copyright>Copyright &amp;copy; 2020 dtan4 All Rights Reserved</copyright><lastBuildDate>Thu, 08 Dec 2016 00:00:00 +0000</lastBuildDate><atom:link href="http://blog-ja.dtan4.net/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>Go でツール書くときの Makefile 晒す</title><link>http://blog-ja.dtan4.net/posts/qiita-8c417b629b6b2033a541/</link><pubDate>Thu, 08 Dec 2016 00:00:00 +0000</pubDate><guid>http://blog-ja.dtan4.net/posts/qiita-8c417b629b6b2033a541/</guid><description>この記事はQiitaの記事をエクスポートしたものです。内容が古くなっている可能性があります。
Go でツール書くときはタスクランナーとして make を使っています。ビルドだけじゃなくて、テストや配布用パッケージ作成も一括して make でやっています。 今回は整理も兼ねて、自分が普段どういう Makefile を使っているのか解剖していきます。
なぜ make を使うのか ビルドフラグ覚えるのが面倒だから、make は (Windows を除く) 大半のプラットフォームに入っていて使いやすいからというのが理由です。script/build みたいにシェルスクリプトを複数用意するのでもまあ良いと思いますが…。大半の Go プロジェクトは Makefile 置いてありますね。
make を使った開発フロー 基本的には、リポジトリを git clone / go get -d した後に以下のコマンドを打てばアプリケーションをインストールできるようにしています。
$ cd $GOPATH/src/github.com/yourname/yourapp $ make deps $ make $ make install $ yourapp 以前 make deps は余分で make &amp;amp;&amp;amp; make install で完結してほしいと言われたことがあったのですが、glide install するオーバーヘッドが（変更なくとも）多少あったので deps は入れました。Kubernetes 系とかデカいの依存してるとね… LL だと bundle install だの npm install だのを独立に行うので、まあいいのではないでしょうか。
変数定義 NAME := s3url VERSION := v0.</description></item><item><title>Travis CI から複数ファイルを GitHub Releases にアップロードする</title><link>http://blog-ja.dtan4.net/posts/qiita-f2736c25c4eb63b2d206/</link><pubDate>Thu, 22 Sep 2016 00:00:00 +0000</pubDate><guid>http://blog-ja.dtan4.net/posts/qiita-f2736c25c4eb63b2d206/</guid><description>この記事はQiitaの記事をエクスポートしたものです。内容が古くなっている可能性があります。
Travis CI から GitHub Releases にアップロードする Go などのコンパイラ言語で書いたソフトウェアを配布する場所として、最近は GitHub Releases を使うことが多いと思います。単純に Git tag と紐付けてファイルをアップロードする場所ですが、手作業でやるのも面倒なので CI と連携させるのが便利です。
Travis CI には Deployment の機能があります。その名の通り、アプリケーションのテスト/ビルド後に、外部の指定した場所へ成果物をデプロイする機能です。デプロイするトリガーとして「特定のブランチ」「git tag がプッシュされた場合のみ」「Go 1.7 ビルドのみ」のような条件が指定できます。
Deployment は、標準で GitHub Releases のインテグレーションを備えています (GitHub Releases Uploading - Travis CI)。GitHub Access Token だけ与えればあとはよしなにアップロードしてくれる便利君ですが、複数ファイルアップロードしたいときに難がありました。
file にアップロード対象のファイルを列挙する 公式ドキュメントで紹介されている方法です。以下は ec2c のバイナリパッケージを12個アップロードする例です。
https://docs.travis-ci.com/user/deployment/releases/#Uploading-Multiple-Files
deploy: provider: releases skip_cleanup: true api_key: $GITHUB_TOKEN file: - dist/ec2c-0.1.0-darwin-386.tar.gz - dist/ec2c-0.1.0-darwin-386.zip - dist/ec2c-0.1.0-darwin-amd64.tar.gz - dist/ec2c-0.1.0-darwin-amd64.zip - dist/ec2c-0.1.0-linux-386.tar.gz - dist/ec2c-0.1.0-linux-386.zip - dist/ec2c-0.1.0-linux-amd64.tar.gz - dist/ec2c-0.1.0-linux-amd64.zip - dist/ec2c-0.</description></item><item><title>Kubernetes の Go API クライアントライブラリを使って Kubernetes を直接操作する</title><link>http://blog-ja.dtan4.net/posts/qiita-f2f30207e0acec454c3d/</link><pubDate>Fri, 20 May 2016 00:00:00 +0000</pubDate><guid>http://blog-ja.dtan4.net/posts/qiita-f2f30207e0acec454c3d/</guid><description>この記事はQiitaの記事をエクスポートしたものです。内容が古くなっている可能性があります。
2016/11/15 10:15 追記
この記事では kubernetes/kubernetes リポジトリに含まれているクライアントライブラリを紹介していますが、今年の8月だか9月になって API クライアントだけが別リポジトリとして切り出されました。
https://github.com/kubernetes/client-go
今後何かツールを作るときは、この client-go を使うのがよいでしょう。
というわけで、以下の内容は__記事初公開時点の、client-go がなかった時代の__ものとなっております。その点ご留意いただいた上でお読みください。
追記終わり
あまり知られてないようですが、Kubernetes には公式の Go 製 API クライアントライブラリがあります。kubectl もこのライブラリを用いて実装されています。
https://github.com/kubernetes/kubernetes/tree/master/pkg/client/
kubectl は確かに万能なんですが、実運用に投入するとなるとその万能さがマイナスに効いてくることもあります。で、自分たちが使いやすいように kubectl をラップした何かを作りたくなるのですが、他の言語から kubectl をサブコマンド呼び出しするのは筋が悪いです。API ライブラリを使ってネイティブレベルで Kubernetes を操作するようにしましょう。
いきなりサンプルコード というわけで、Pod の名前一覧を表示するだけのサンプルコードです。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; &amp;#34;k8s.io/kubernetes/pkg/api&amp;#34; client &amp;#34;k8s.io/kubernetes/pkg/client/unversioned&amp;#34; &amp;#34;k8s.io/kubernetes/pkg/client/unversioned/clientcmd&amp;#34; ) func newKubeClient() (*client.Client, error) { loadingRules := clientcmd.NewDefaultClientConfigLoadingRules() loadingRules.ExplicitPath = clientcmd.RecommendedHomeFile loader := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(loadingRules, &amp;amp;clientcmd.ConfigOverrides{}) clientConfig, err := loader.ClientConfig() if err != nil { return nil, err } kubeClient, err := client.</description></item><item><title>Go でコメントアウトせずに素早く複数行スキップさせる</title><link>http://blog-ja.dtan4.net/posts/qiita-5efab45307203c46e424/</link><pubDate>Mon, 18 Apr 2016 00:00:00 +0000</pubDate><guid>http://blog-ja.dtan4.net/posts/qiita-5efab45307203c46e424/</guid><description>この記事はQiitaの記事をエクスポートしたものです。内容が古くなっている可能性があります。
TL; DR if false {} でスキップしたい箇所を囲む
本文 Go では宣言されてるのに使われてない変数があると、ビルド時に hoge declared and not used といった感じで怒られます。 Go 書いてる時、デバッグ目的で処理を飛ばそうと複数行コメントアウトしたくなる時があります。が、適当にやると変数の宣言だけが残って前述のように怒られることがあります。この場合は改めて宣言箇所だけコメントアウトすればビルドが通りますが、まあ面倒ですよね。
こういう時は、該当箇所を if false {} で囲ってやればよいです。見てわかるように、常に false なのでブロックの中は実行されません。
Example 元のコード package main import ( &amp;#34;fmt&amp;#34; ) func main() { hogeMessage := &amp;#34;hoge&amp;#34; fugaMessage := &amp;#34;fuga&amp;#34; piyoMessage := &amp;#34;piyo&amp;#34; hogehogeMessage := &amp;#34;hogehoge&amp;#34; fmt.Println(hogeMessage) fmt.Println(fugaMessage) fmt.Println(piyoMessage) fmt.Println(hogehogeMessage) } $ go run hoge.go hoge fuga piyo hogehoge コメントアウトすると… package main import ( &amp;#34;fmt&amp;#34; ) func main() { hogeMessage := &amp;#34;hoge&amp;#34; fugaMessage := &amp;#34;fuga&amp;#34; piyoMessage := &amp;#34;piyo&amp;#34; hogehogeMessage := &amp;#34;hogehoge&amp;#34; fmt.</description></item></channel></rss>