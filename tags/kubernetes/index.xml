<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>kubernetes on blog-ja.dtan4.net</title><link>https://dtan4.github.io/blog-ja/tags/kubernetes/</link><description>Recent content in kubernetes on blog-ja.dtan4.net</description><generator>Hugo -- gohugo.io</generator><language>ja-JP</language><copyright>Copyright &amp;copy; 2020 dtan4 All Rights Reserved</copyright><lastBuildDate>Mon, 18 Dec 2017 00:00:00 +0000</lastBuildDate><atom:link href="https://dtan4.github.io/blog-ja/tags/kubernetes/index.xml" rel="self" type="application/rss+xml"/><item><title>全ての Pod を一発でリロードさせる方法</title><link>https://dtan4.github.io/blog-ja/posts/qiita-9e0ab5dbe8c64ed6dd21/</link><pubDate>Mon, 18 Dec 2017 00:00:00 +0000</pubDate><guid>https://dtan4.github.io/blog-ja/posts/qiita-9e0ab5dbe8c64ed6dd21/</guid><description>この記事はQiitaの記事をエクスポートしたものです。内容が古くなっている可能性があります。
前提条件:
Deployment を使ってアプリケーションのデプロイ管理を行っている tl;dr PodTemplateSpec の Label か Annotation (.spec.template.metadata.[labels|annotations]) に適当な key-value を追加・上書きする。 value はタイムスタンプにでもしておくと便利。
apiVersion: extensions/v1beta1 kind: Deployment metadata: name: awesome-app labels: name: awesome-app role: web spec: minReadySeconds: 30 strategy: type: RollingUpdate rollingUpdate: maxSurge: 50% maxUnavailable: 0 replicas: 20 template: metadata: name: awesome-app labels: name: awesome-app role: web annotations: reloaded-at: &amp;#34;20171217190756&amp;#34; # &amp;lt;========== これ シェルコマンド一発でやるなら以下。エイリアス作っておくと便利。
# &amp;#34;frontend&amp;#34; Deployment 配下の Pod を全部リロードする $ kubectl patch deployment frontend -p \ &amp;#34;{\&amp;#34;spec\&amp;#34;:{\&amp;#34;template\&amp;#34;:{\&amp;#34;metadata\&amp;#34;:{\&amp;#34;annotations\&amp;#34;:{\&amp;#34;reloaded-at\&amp;#34;:\&amp;#34;`date +&amp;#39;%Y%m%d%H%M%S&amp;#39;`\&amp;#34;}}}}}&amp;#34; Why Kubernetes で Pod に設定を注入するには ConfigMap や Secret が主に使われます。 これらの中身は Pod 起動時に Pod へコピーされる仕組みとなっているため、アプリケーション起動中に中身を変更してもそれが即反映されるわけではありません。 Pod を作りなおす必要があります。</description></item><item><title>Kubernetes の Go API クライアントライブラリを使って Kubernetes を直接操作する</title><link>https://dtan4.github.io/blog-ja/posts/qiita-f2f30207e0acec454c3d/</link><pubDate>Fri, 20 May 2016 00:00:00 +0000</pubDate><guid>https://dtan4.github.io/blog-ja/posts/qiita-f2f30207e0acec454c3d/</guid><description>この記事はQiitaの記事をエクスポートしたものです。内容が古くなっている可能性があります。
2016/11/15 10:15 追記
この記事では kubernetes/kubernetes リポジトリに含まれているクライアントライブラリを紹介していますが、今年の8月だか9月になって API クライアントだけが別リポジトリとして切り出されました。
https://github.com/kubernetes/client-go
今後何かツールを作るときは、この client-go を使うのがよいでしょう。
というわけで、以下の内容は__記事初公開時点の、client-go がなかった時代の__ものとなっております。その点ご留意いただいた上でお読みください。
追記終わり
あまり知られてないようですが、Kubernetes には公式の Go 製 API クライアントライブラリがあります。kubectl もこのライブラリを用いて実装されています。
https://github.com/kubernetes/kubernetes/tree/master/pkg/client/
kubectl は確かに万能なんですが、実運用に投入するとなるとその万能さがマイナスに効いてくることもあります。で、自分たちが使いやすいように kubectl をラップした何かを作りたくなるのですが、他の言語から kubectl をサブコマンド呼び出しするのは筋が悪いです。API ライブラリを使ってネイティブレベルで Kubernetes を操作するようにしましょう。
いきなりサンプルコード というわけで、Pod の名前一覧を表示するだけのサンプルコードです。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; &amp;#34;k8s.io/kubernetes/pkg/api&amp;#34; client &amp;#34;k8s.io/kubernetes/pkg/client/unversioned&amp;#34; &amp;#34;k8s.io/kubernetes/pkg/client/unversioned/clientcmd&amp;#34; ) func newKubeClient() (*client.Client, error) { loadingRules := clientcmd.NewDefaultClientConfigLoadingRules() loadingRules.ExplicitPath = clientcmd.RecommendedHomeFile loader := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(loadingRules, &amp;amp;clientcmd.ConfigOverrides{}) clientConfig, err := loader.ClientConfig() if err != nil { return nil, err } kubeClient, err := client.</description></item></channel></rss>