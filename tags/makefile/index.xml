<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Makefile on blog-ja.dtan4.net</title><link>https://blog-ja.dtan4.net/tags/makefile/</link><description>Recent content in Makefile on blog-ja.dtan4.net</description><generator>Hugo -- gohugo.io</generator><language>ja-JP</language><copyright>Copyright &amp;copy; 2020 dtan4 All Rights Reserved</copyright><lastBuildDate>Thu, 08 Dec 2016 00:00:00 +0000</lastBuildDate><atom:link href="https://blog-ja.dtan4.net/tags/makefile/index.xml" rel="self" type="application/rss+xml"/><item><title>Go でツール書くときの Makefile 晒す</title><link>https://blog-ja.dtan4.net/posts/qiita-8c417b629b6b2033a541/</link><pubDate>Thu, 08 Dec 2016 00:00:00 +0000</pubDate><guid>https://blog-ja.dtan4.net/posts/qiita-8c417b629b6b2033a541/</guid><description>この記事はQiitaの記事をエクスポートしたものです。内容が古くなっている可能性があります。
Go でツール書くときはタスクランナーとして make を使っています。ビルドだけじゃなくて、テストや配布用パッケージ作成も一括して make でやっています。 今回は整理も兼ねて、自分が普段どういう Makefile を使っているのか解剖していきます。
なぜ make を使うのか ビルドフラグ覚えるのが面倒だから、make は (Windows を除く) 大半のプラットフォームに入っていて使いやすいからというのが理由です。script/build みたいにシェルスクリプトを複数用意するのでもまあ良いと思いますが…。大半の Go プロジェクトは Makefile 置いてありますね。
make を使った開発フロー 基本的には、リポジトリを git clone / go get -d した後に以下のコマンドを打てばアプリケーションをインストールできるようにしています。
$ cd $GOPATH/src/github.com/yourname/yourapp $ make deps $ make $ make install $ yourapp 以前 make deps は余分で make &amp;amp;&amp;amp; make install で完結してほしいと言われたことがあったのですが、glide install するオーバーヘッドが（変更なくとも）多少あったので deps は入れました。Kubernetes 系とかデカいの依存してるとね… LL だと bundle install だの npm install だのを独立に行うので、まあいいのではないでしょうか。
変数定義 NAME := s3url VERSION := v0.</description></item></channel></rss>